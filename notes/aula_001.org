#+title: Aula 001: Python √© bonitinho

* Intro para windows üôÑ
Vai toma no cu po

** Python
Primeiro ver se j√° t√° instalado:
+ Tacar ~python --version~ no command prompt

Instalando:
1. [[https://www.python.org/]]
2. 'Downloads', baixar
3. abrir o installer e checka o 'Add Python to path', instalar
4. abrir o prompt de comand de novo com ~python --version~ pra confirmar

** Editor de texto
Escolhas...
M√≥ parada...
Vamo de VSCodium...

Instalando:
1. [[https://vscodium.com/]], achar o link pros releases do github
2. procurar por ~.msi~, baixar, rodar
3. configurar..........................
   + escolher tema
   + baixar extens√µes (Python)

** Executando um arquivo ~.py~
Criar uma pasta para o curso e criar um arquivo ~aula_001.py~ pra aula de hoje:
#+begin_src python
print("Ol√°, mundo!")
#+end_src

Para executar temos algumas op√ß√µes:
+ Executar na m√£o (based):
  Navegar at√© a pasta pelo prompt de comando e executar com ~python <arquivo>~
+ Executar pelo VSCodium (soy):
  1. No VSCodium, ~<CTRL><SHIFT>p~, 'select python interpreter' e selecionar python 3
  2. Pra rodar tem as seguintes op√ß√µes
     + Clickar no bot√£o de play no topo/direita
     + ~<CTRL><SHIFT>p~ ou right click e "run python in terminal"

Pronto!
Bora programar??! haha

* Operadores aritm√©ticos
Os b√°sicos:
#+begin_src python
print(1 + 2)
print(1 - 2)
print(1 / 2)
print(1 * 2)

# e se eu fizer com strings?
print("Ol√°, " + "mundo" + "!")
#+end_src

Observa√ß√µes:
1. o c√≥digo executa linha por linha
2. espa√ßos no c√≥digo s√£o ignorados e s√£o usados para deixar as coisas mais leg√≠veis (~1+1*3/2~ vs ~1 + 1 * 3 / 2~)
3. coment√°rios n√£o afetam o c√≥digo e s√£o usados para dar infos

* Vari√°veis
S√£o caixinhas onde a gente vai guardar informa√ß√£o.
#+begin_src python
nome = "Nassu"
print("Ol√°, " + nome + "!")
print("Como vai, " + nome + "?")
print("Ok beleza xau, " + nome + "!")
#+end_src

Se eu quiser mudar o nome √© s√≥ eu mudar o que t√° guardado dentro da caixinha chamada ~nome~. Ou seja, mudar s√≥ a primeira linha, o resto continua funcionando!

Vars podem guardar v√°rios tipos de informa√ß√£o:
#+begin_src python
nome = "Nassu"
idade = 25
cidade = "Rio de Janeiro"
estado = "RJ"
casado = False
print(f"{nome} tem {idade} anos e mora em {cidade}, {estado}.")
#+end_src
A gente vai ver mais tipos depois...

Eu consigo reatribuir valores a uma var:
#+begin_src python
nome = "Nassu"
nome = "Tomas"
print(nome)

nome = 10
print(nome)
#+end_src

Observa√ß√µes:
+ Nome de vars:
  - letras, n√∫meros (n√£o no come√ßo) ou "_"
  - n√£o pode come√ßar com n√∫mero
  - n√£o pode ser palavras j√° usadas como keywords do python (break, try, for...)
  - case sensitive
  - a regra pra nomear √© ser simples mais descriptivo

* Recebendo input
#+begin_src python
nome = input("Qual √© o seu nome?\n")
print(f"Ol√°, {nome}!")
#+end_src

* Trabalhando com o tipo certo
Quando eu recebo um input com ~input()~, o resultado retornado que vai ser atribu√≠do √† var sera um valor do tipo ~str~.
#+begin_src python
nome = input("Qual √© o seu nome?\n")
print(type(nome))

idade = input("Qual √© sua idade?\n")
print(type(idade))
# print(idade + 10) # da erro
#+end_src

Se a gente quiser, por exemplo, transformar uma string "41" no n√∫mero inteiro 41, fazemos type casting:
#+begin_src python
numero = int("41")
print(type(numero))
print(numero + 10) # nao da erro
#+end_src

Ent√£o, se quisermos pegar a idade do usu√°rio usando a fun√ß√£o ~input()~, fazemos:
#+begin_src python
idade = int(input("qual √© sua idade?\n"))
print(type(idade))
print(idade + 10) # nao da erro
#+end_src

* Condicionais
Tem como a gente escolher maneiras diferentes de fazer agir dependendo de uma condi√ß√£o.

Exemplo: queremos barrar todos os menores de idade tentando comprar cacha√ßa.
1. verificar idade do meliante
2. se idade for maior ou igual a 18, liberar a cacha√ßa
3. se n√£o, barrar o menor
#+begin_src python
idade = int(input("qual √© sua idade?\n"))

if idade >= 18:
    print("tome cacha√ßa")
else:
    print("v√° estudar, crian√ßa")
#+end_src

Observa√ß√µes:
+ Indenta√ß√£o! Falar sobre a ideia de bloco de codigo.
  O python reconhece um bloco de c√≥digo apenas pela indenta√ß√£o. Tomar cuidado para indentar direito.

** ~elif~
Joguinho idiota: eu, o programador, vou definir um n√∫mero. O usu√°rio dever√° adivinhar o n√∫mero que eu defini. Beleza?..ok
#+begin_src python
numero_sagrado = 41
chute = int(input("Tente adivinhar o n√∫mero sagrado:\n"))

if chute == numero_sagrado:
    print("parabens voc√™ ganhou haha eba!")
else:
    print("idiota")
#+end_src

Agora, se eu quiser dar uma dica pro usu√°rio pra pr√≥xima vez que ele jogar?
#+begin_src python
numero_sagrado = 41
chute = int(input("Tente adivinhar o n√∫mero sagrado:\n"))

if chute == numero_sagrado:
    print("parabens voc√™ ganhou haha eba!")
elif chute > numero_sagrado:
    print("voc√™ chutou alto")
else:
    print("voc√™ chutou baixo")
#+end_src


* ~while~
√â a ideia de repetir um processo enquanto uma condi√ß√£o estiver sendo satisfeita.

Se quisermos que o usu√°rio continue repetindo o chute dele at√© ele acertar:
#+begin_src python
numero_sagrado = 41
acertou = False

while not acertou:
    chute = int(input("Tente adivinhar o n√∫mero sagrado:\n"))

    if chute == numero_sagrado:
        print("parabens voc√™ ganhou haha eba!")
        acertou = True
    elif chute > numero_sagrado:
        print("voc√™ chutou alto")
    else:
        print("voc√™ chutou baixo")
#+end_src

E se quisermos que tenha no m√°ximo 10 chutes?
#+begin_src python
contador_chute = 0
numero_sagrado = 41
acertou = False

while not acertou and contador_chute < 10:
    chute = int(input("Tente adivinhar o n√∫mero sagrado:\n"))
    contador_chute += 1

    if chute == numero_sagrado:
        print("parabens voc√™ ganhou haha eba!")
        acertou = True
    elif chute > numero_sagrado:
        print("voc√™ chutou alto")
    else:
        print("voc√™ chutou baixo")
#+end_src

* Listas
Lista ordenanda n√£o homogenea.
#+begin_src python
nomes = ["Nassu", "Tom√°m", "Seu Z√©", "Amelia", "Jorge", "Canildo"]
i = 0

while i < len(nomes):
    print(nomes[i])
    i += 1


# achando o maior numero
nums = [32, 100, 2, -12, 4, 3, 5, 10, -50]
max_num = 32
i = 1
while i < len(nums):
    if nums[i] > max_num:
        max_num = nums[i]
    i += 1

print(max_num)
#+end_src

* ~for~
Para elemento dentro de elementos.
#+begin_src python
nums = [32, 100, 2, -12, 4, 3, 5, 10, -50]
max_num = 32

for num in nums:
    if num > max_num:
        max_num = num

print(max_num)
#+end_src

+ ~range~
#+begin_src python
for i in range(10):
    print(i)

for i in range(0, 10, 3):
    print(i)
#+end_src

* Fun√ß√µes
Empacotar um peda√ßo de c√≥digo para:
+ isolar a l√≥gica
+ tornar o c√≥digo mais leg√≠vel
+ reusar peda√ßo de c√≥digo sem ter que copiar inteiro
#+begin_src python
def ola_mundo():
    print("Ol√°, mundo!")

def contem(numeros, x):
    for num in numeros:
        if num == x:
            return True

    return False

def achar_max(numeros):
    max_num = lista[0]

    for i in range(1, len(lista)):
        if lista[i] > max_num:
            max_num = lista[i]

    return max_num
#+end_src
